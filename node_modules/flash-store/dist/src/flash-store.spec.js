#!/usr/bin/env ts-node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const blue_tape_1 = __importDefault(require("blue-tape"));
// import { log }    from './config'
// log.level('silly')
const flash_store_1 = require("./flash-store");
const KEY = 'test-key';
const VAL = 'test-val';
const VAL_OBJ = { obj_key: 'obj_val' };
blue_tape_1.default('constructor()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const tmpDir = fs_1.default.mkdtempSync(path_1.default.join(os_1.default.tmpdir(), path_1.default.sep, 'flash-store-'));
    t.doesNotThrow(() => __awaiter(void 0, void 0, void 0, function* () {
        const store = new flash_store_1.FlashStore(tmpDir);
        // need to do something to create the db directory
        yield store.delete('init');
        t.ok(fs_1.default.existsSync(tmpDir), 'should create the workDir');
        yield store.destroy();
    }), 'should not throw exception with a non existing workDir');
}));
blue_tape_1.default('version()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    var e_1, _a;
    try {
        for (var _b = __asyncValues(storeFixture()), _c; _c = yield _b.next(), !_c.done;) {
            const store = _c.value;
            t.ok(store.version().match(/^\d+\.\d+\.\d+$/), 'should get semver version');
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
}));
blue_tape_1.default('Store as async iterator', (t) => __awaiter(void 0, void 0, void 0, function* () {
    t.test('async iterator for empty store', (t) => __awaiter(void 0, void 0, void 0, function* () {
        var e_2, _d, e_3, _e;
        try {
            for (var _f = __asyncValues(storeFixture()), _g; _g = yield _f.next(), !_g.done;) {
                const store = _g.value;
                let n = 0;
                try {
                    /* eslint @typescript-eslint/no-unused-vars: off */
                    for (var store_1 = __asyncValues(store), store_1_1; store_1_1 = yield store_1.next(), !store_1_1.done;) {
                        const _ = store_1_1.value;
                        n++;
                        break;
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (store_1_1 && !store_1_1.done && (_e = store_1.return)) yield _e.call(store_1);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                t.equal(n, 0, 'should get empty iterator');
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_d = _f.return)) yield _d.call(_f);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }));
    t.test('async iterator', (t) => __awaiter(void 0, void 0, void 0, function* () {
        var e_4, _h, e_5, _j;
        try {
            for (var _k = __asyncValues(storeFixture()), _l; _l = yield _k.next(), !_l.done;) {
                const store = _l.value;
                yield store.set(KEY, VAL);
                let n = 0;
                try {
                    for (var store_2 = __asyncValues(store), store_2_1; store_2_1 = yield store_2.next(), !store_2_1.done;) {
                        const [key, val] = store_2_1.value;
                        t.equal(key, KEY, 'should get key back');
                        t.equal(val, VAL, 'should get val back');
                        n++;
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (store_2_1 && !store_2_1.done && (_j = store_2.return)) yield _j.call(store_2);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
                t.equal(n, 1, 'should iterate once');
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_l && !_l.done && (_h = _k.return)) yield _h.call(_k);
            }
            finally { if (e_4) throw e_4.error; }
        }
    }));
}));
blue_tape_1.default('async get()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    t.test('return undefined for non existing key', (t) => __awaiter(void 0, void 0, void 0, function* () {
        var e_6, _m;
        try {
            for (var _o = __asyncValues(storeFixture()), _p; _p = yield _o.next(), !_p.done;) {
                const store = _p.value;
                const val = yield store.get(KEY);
                t.equal(val, undefined, 'should get undefined for not exist key');
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_p && !_p.done && (_m = _o.return)) yield _m.call(_o);
            }
            finally { if (e_6) throw e_6.error; }
        }
    }));
    t.test('store string key/val', (t) => __awaiter(void 0, void 0, void 0, function* () {
        var e_7, _q;
        try {
            for (var _r = __asyncValues(storeFixture()), _s; _s = yield _r.next(), !_s.done;) {
                const store = _s.value;
                yield store.set(KEY, VAL);
                const val = yield store.get(KEY);
                t.equal(val, VAL, 'should get VAL after set KEY');
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_s && !_s.done && (_q = _r.return)) yield _q.call(_r);
            }
            finally { if (e_7) throw e_7.error; }
        }
    }));
    t.test('store object value', (t) => __awaiter(void 0, void 0, void 0, function* () {
        var e_8, _t;
        try {
            for (var _u = __asyncValues(storeFixture()), _v; _v = yield _u.next(), !_v.done;) {
                const store = _v.value;
                yield store.set(KEY, VAL_OBJ);
                const val = yield store.get(KEY);
                t.deepEqual(val, VAL_OBJ, 'should get VAL_OBJ after set KEY');
            }
        }
        catch (e_8_1) { e_8 = { error: e_8_1 }; }
        finally {
            try {
                if (_v && !_v.done && (_t = _u.return)) yield _t.call(_u);
            }
            finally { if (e_8) throw e_8.error; }
        }
    }));
}));
blue_tape_1.default('async set()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    var e_9, _w;
    try {
        for (var _x = __asyncValues(storeFixture()), _y; _y = yield _x.next(), !_y.done;) {
            const store = _y.value;
            yield store.set(KEY, VAL);
            const val = yield store.get(KEY);
            t.equal(val, VAL, 'should set VAL for KEY');
        }
    }
    catch (e_9_1) { e_9 = { error: e_9_1 }; }
    finally {
        try {
            if (_y && !_y.done && (_w = _x.return)) yield _w.call(_x);
        }
        finally { if (e_9) throw e_9.error; }
    }
}));
// TODO: wait https://github.com/ClickSimply/snap-db/pull/12
blue_tape_1.default('set the same key more than one time, and the size should be 1', (t) => __awaiter(void 0, void 0, void 0, function* () {
    var e_10, _z;
    try {
        for (var _0 = __asyncValues(storeFixture()), _1; _1 = yield _0.next(), !_1.done;) {
            const store = _1.value;
            yield store.set(KEY, VAL);
            yield store.set(KEY, VAL);
            yield store.set(KEY, VAL);
            const size = yield store.size;
            t.equal(size, 1, 'the size should be 1');
        }
    }
    catch (e_10_1) { e_10 = { error: e_10_1 }; }
    finally {
        try {
            if (_1 && !_1.done && (_z = _0.return)) yield _z.call(_0);
        }
        finally { if (e_10) throw e_10.error; }
    }
}));
blue_tape_1.default('async size()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    var e_11, _2;
    try {
        for (var _3 = __asyncValues(storeFixture()), _4; _4 = yield _3.next(), !_4.done;) {
            const store = _4.value;
            let size = yield store.size;
            t.equal(size, 0, 'should get size 0 after init');
            yield store.set(KEY, VAL);
            size = yield store.size;
            t.equal(size, 1, 'should get count 1 after put');
        }
    }
    catch (e_11_1) { e_11 = { error: e_11_1 }; }
    finally {
        try {
            if (_4 && !_4.done && (_2 = _3.return)) yield _2.call(_3);
        }
        finally { if (e_11) throw e_11.error; }
    }
}));
blue_tape_1.default('async keys()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    var e_12, _5, e_13, _6, e_14, _7;
    try {
        for (var _8 = __asyncValues(storeFixture()), _9; _9 = yield _8.next(), !_9.done;) {
            const store = _9.value;
            let count = 0;
            try {
                for (var _10 = __asyncValues(store.keys()), _11; _11 = yield _10.next(), !_11.done;) {
                    const _ = _11.value;
                    count++;
                }
            }
            catch (e_13_1) { e_13 = { error: e_13_1 }; }
            finally {
                try {
                    if (_11 && !_11.done && (_6 = _10.return)) yield _6.call(_10);
                }
                finally { if (e_13) throw e_13.error; }
            }
            t.equal(count, 0, 'should get 0 key after init');
            yield store.set(KEY, VAL);
            try {
                for (var _12 = __asyncValues(store.keys()), _13; _13 = yield _12.next(), !_13.done;) {
                    const key = _13.value;
                    t.equal(key, KEY, 'should get back the key');
                    count++;
                }
            }
            catch (e_14_1) { e_14 = { error: e_14_1 }; }
            finally {
                try {
                    if (_13 && !_13.done && (_7 = _12.return)) yield _7.call(_12);
                }
                finally { if (e_14) throw e_14.error; }
            }
            t.equal(count, 1, 'should get 1 key after 1 put');
        }
    }
    catch (e_12_1) { e_12 = { error: e_12_1 }; }
    finally {
        try {
            if (_9 && !_9.done && (_5 = _8.return)) yield _5.call(_8);
        }
        finally { if (e_12) throw e_12.error; }
    }
}));
blue_tape_1.default('async values()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    var e_15, _14, e_16, _15, e_17, _16;
    try {
        for (var _17 = __asyncValues(storeFixture()), _18; _18 = yield _17.next(), !_18.done;) {
            const store = _18.value;
            let count = 0;
            try {
                for (var _19 = __asyncValues(store.values()), _20; _20 = yield _19.next(), !_20.done;) {
                    const _ = _20.value;
                    count++;
                }
            }
            catch (e_16_1) { e_16 = { error: e_16_1 }; }
            finally {
                try {
                    if (_20 && !_20.done && (_15 = _19.return)) yield _15.call(_19);
                }
                finally { if (e_16) throw e_16.error; }
            }
            t.equal(count, 0, 'should get 0 value after init');
            yield store.set(KEY, VAL);
            try {
                for (var _21 = __asyncValues(store.values()), _22; _22 = yield _21.next(), !_22.done;) {
                    const value = _22.value;
                    t.equal(value, VAL, 'should get back the value');
                    count++;
                }
            }
            catch (e_17_1) { e_17 = { error: e_17_1 }; }
            finally {
                try {
                    if (_22 && !_22.done && (_16 = _21.return)) yield _16.call(_21);
                }
                finally { if (e_17) throw e_17.error; }
            }
            t.equal(count, 1, 'should get 1 value after 1 put');
        }
    }
    catch (e_15_1) { e_15 = { error: e_15_1 }; }
    finally {
        try {
            if (_18 && !_18.done && (_14 = _17.return)) yield _14.call(_17);
        }
        finally { if (e_15) throw e_15.error; }
    }
}));
blue_tape_1.default('close() twice gracefully', (t) => __awaiter(void 0, void 0, void 0, function* () {
    var e_18, _23;
    try {
        // https://github.com/ClickSimply/snap-db/issues/10
        for (var _24 = __asyncValues(storeFixture()), _25; _25 = yield _24.next(), !_25.done;) {
            const store = _25.value;
            try {
                yield store.close();
                yield store.close();
                // console.info(store)
                t.pass('close() can be invoked more than one times');
            }
            catch (e) {
                // console.info('wtf?', e || 'rejection')
                t.fail(e || 'rejection');
            }
        }
    }
    catch (e_18_1) { e_18 = { error: e_18_1 }; }
    finally {
        try {
            if (_25 && !_25.done && (_23 = _24.return)) yield _23.call(_24);
        }
        finally { if (e_18) throw e_18.error; }
    }
    // t.pass('end')
    // console.info('haha')
}));
blue_tape_1.default('first time size', (t) => __awaiter(void 0, void 0, void 0, function* () {
    var e_19, _26;
    try {
        for (var _27 = __asyncValues(storeFixture()), _28; _28 = yield _27.next(), !_28.done;) {
            const store = _28.value;
            try {
                const workdir = store.workdir;
                yield store.set('foo', 'bar');
                yield store.close();
                const oldStore = new flash_store_1.FlashStore(workdir);
                t.equal(yield oldStore.size, 1, 'should get size 1 after re-open a old store.');
            }
            catch (e) {
                // console.info('wtf?', e || 'rejection')
                t.fail(e || 'rejection');
            }
        }
    }
    catch (e_19_1) { e_19 = { error: e_19_1 }; }
    finally {
        try {
            if (_28 && !_28.done && (_26 = _27.return)) yield _26.call(_27);
        }
        finally { if (e_19) throw e_19.error; }
    }
    // t.pass('end')
    // console.info('haha')
}));
// To be fixed: https://github.com/huan/flash-store/issues/4
blue_tape_1.default.skip('values({ optioin: gte/lte })', (t) => __awaiter(void 0, void 0, void 0, function* () {
    var e_20, _29, e_21, _30, e_22, _31;
    try {
        for (var _32 = __asyncValues(storeFixture()), _33; _33 = yield _32.next(), !_33.done;) {
            const store = _33.value;
            try {
                yield store.set('a', 3);
                yield store.set('b', 5);
                try {
                    for (var _34 = __asyncValues(store.values({ gte: 4 })), _35; _35 = yield _34.next(), !_35.done;) {
                        const value = _35.value;
                        t.equal(value, 5, 'gte 4 should get 5');
                    }
                }
                catch (e_21_1) { e_21 = { error: e_21_1 }; }
                finally {
                    try {
                        if (_35 && !_35.done && (_30 = _34.return)) yield _30.call(_34);
                    }
                    finally { if (e_21) throw e_21.error; }
                }
                try {
                    for (var _36 = __asyncValues(store.values({ lte: 4 })), _37; _37 = yield _36.next(), !_37.done;) {
                        const value = _37.value;
                        t.equal(value, 4, 'lte 4 should get 4');
                    }
                }
                catch (e_22_1) { e_22 = { error: e_22_1 }; }
                finally {
                    try {
                        if (_37 && !_37.done && (_31 = _36.return)) yield _31.call(_36);
                    }
                    finally { if (e_22) throw e_22.error; }
                }
            }
            catch (e) {
                t.fail(e || 'rejection');
            }
        }
    }
    catch (e_20_1) { e_20 = { error: e_20_1 }; }
    finally {
        try {
            if (_33 && !_33.done && (_29 = _32.return)) yield _29.call(_32);
        }
        finally { if (e_20) throw e_20.error; }
    }
}));
blue_tape_1.default('create workdir if it is not exist', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const tmpDir = fs_1.default.mkdtempSync(path_1.default.join(os_1.default.tmpdir(), path_1.default.sep, 'flash-store-'));
    const notExistWorkDir = path_1.default.join(tmpDir, 'not-exist-dir');
    const store = new flash_store_1.FlashStore(notExistWorkDir);
    const KEY = 'life';
    const VAL = 42;
    yield store.set(KEY, VAL);
    const val = yield store.get(KEY);
    t.equal(val, VAL, 'should work without problem with a not existing workdir by creating it automatically.');
    yield store.destroy();
}));
blue_tape_1.default('Only one instance can use the database directory', (t) => __awaiter(void 0, void 0, void 0, function* () {
    var e_23, _38;
    try {
        for (var _39 = __asyncValues(storeFixture()), _40; _40 = yield _39.next(), !_40.done;) {
            const store = _40.value;
            try {
                const workdir = store.workdir;
                /**
                 * We have to active the store becasue the medae is lazy initializing.
                 */
                yield store.size;
                try {
                    const anotherStore = new flash_store_1.FlashStore(workdir);
                    void anotherStore;
                    t.fail('should not be instanciated because the workdir is busy.');
                }
                catch (e) {
                    t.pass('should throw if another store has already been using the workdir');
                }
            }
            catch (e) {
                t.fail(e || 'rejection');
            }
        }
    }
    catch (e_23_1) { e_23 = { error: e_23_1 }; }
    finally {
        try {
            if (_40 && !_40.done && (_38 = _39.return)) yield _38.call(_39);
        }
        finally { if (e_23) throw e_23.error; }
    }
}));
blue_tape_1.default('compact()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    var e_24, _41;
    try {
        for (var _42 = __asyncValues(storeFixture()), _43; _43 = yield _42.next(), !_43.done;) {
            const store = _43.value;
            try {
                yield store.size;
                const db = store.levelDb.db.db.db;
                yield new Promise((resolve, reject) => {
                    db.compact((err) => {
                        if (err) {
                            return reject(err);
                        }
                        resolve();
                    });
                });
                t.pass('compacted');
            }
            catch (e) {
                t.fail(e);
            }
        }
    }
    catch (e_24_1) { e_24 = { error: e_24_1 }; }
    finally {
        try {
            if (_43 && !_43.done && (_41 = _42.return)) yield _41.call(_42);
        }
        finally { if (e_24) throw e_24.error; }
    }
}));
/**
 * Fixtures
 */
function storeFixture() {
    return __asyncGenerator(this, arguments, function* storeFixture_1() {
        const tmpDir = fs_1.default.mkdtempSync(path_1.default.join(os_1.default.tmpdir(), path_1.default.sep, 'flash-store-'));
        const store = new flash_store_1.FlashStore(tmpDir);
        yield yield __await(store);
        yield __await(store.destroy());
    });
}
//# sourceMappingURL=flash-store.spec.js.map