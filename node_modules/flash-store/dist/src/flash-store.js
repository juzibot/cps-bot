"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __asyncDelegator = (this && this.__asyncDelegator) || function (o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const fs_ext_1 = require("fs-ext");
const app_root_path_1 = require("app-root-path");
const rimraf_1 = __importDefault(require("rimraf"));
const encoding_down_1 = __importDefault(require("encoding-down"));
const levelup_1 = __importDefault(require("levelup"));
const medeadown_1 = __importDefault(require("medeadown"));
const config_1 = require("./config");
class FlashStore {
    /**
     * FlashStore is a Key-Value database tool and makes using leveldb more easy for Node.js
     *
     * Creates an instance of FlashStore.
     * @param {string} [workdir=path.join(appRoot, 'flash-store.workdir')]
     * @example
     * import { FlashStore } from 'flash-store'
     * const flashStore = new FlashStore('flashstore.workdir')
     */
    constructor(workdir) {
        this.workdir = workdir;
        if (!this.workdir) {
            this.workdir = path_1.default.join(app_root_path_1.path, '.flash-store');
        }
        if (fs_1.default.existsSync(this.workdir)) {
            config_1.log.verbose('FlashStore', 'constructor(%s)', workdir);
        }
        else {
            /**
              * Mkdir for the database directory. (only for the last path, no recursive)
              */
            config_1.log.silly('FlashStore', 'constructor(%s) not exist, creating...', this.workdir);
            try {
                fs_1.default.mkdirSync(this.workdir);
            }
            catch (e) {
                config_1.log.error('FlashStore', 'constructor(%s) exception: %s', this.workdir, e && e.message);
                throw e;
            }
            config_1.log.silly('FlashStore', 'constructor(%s) workdir created.', this.workdir);
        }
        const lockFile = path_1.default.join(this.workdir, 'flash-store.lock');
        this.lockFd = fs_1.default.openSync(lockFile, 'w');
        try {
            fs_ext_1.flockSync(this.lockFd, 'exnb');
        }
        catch (e) {
            config_1.log.error('FlashStore', 'constructor() workdir("%s") is busy: maybe there another FlashStore are using it?', this.workdir);
            throw e;
        }
        // we use seperate workdir for snapdb, leveldb, and rocksdb etc.
        const medeaWorkdir = path_1.default.join(this.workdir, 'medea');
        const medeaDown = medeadown_1.default(medeaWorkdir);
        this.medeaKeyDir = medeaDown.db.keydir;
        // https://twitter.com/juliangruber/status/908688876381892608
        const encoded = encoding_down_1.default(
        // leveldown(workdir),
        medeaDown, {
            // FIXME: issue #2
            valueEncoding: 'json',
        });
        this.levelDb = levelup_1.default(encoded);
        // console.log((this.levelDb as any)._db.codec)
        this.levelDb.setMaxListeners(17); // default is Infinity
    }
    version() {
        return config_1.VERSION;
    }
    /**
     * Set data in database
     *
     * @param {K} key
     * @param {V} value
     * @returns {Promise<void>}
     * @example
     * await flashStore.set(1, 1)
     */
    set(key, value) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('FlashStore', 'set(%s, %s) value type: %s', key, JSON.stringify(value), typeof value);
            yield this.levelDb.put(key, JSON.stringify(value));
        });
    }
    /**
     * Get value from database by key
     *
     * @param {K} key
     * @returns {(Promise<V | null>)}
     * @example
     * console.log(await flashStore.get(1))
     */
    get(key) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('FlashStore', 'get(%s)', key);
            try {
                return JSON.parse(yield this.levelDb.get(key));
            }
            catch (e) {
                if (/^NotFoundError/.test(e)) {
                    // The leveldb will throw NotFoundError for non-exist keys
                    return undefined;
                }
                throw e;
            }
        });
    }
    /**
     * Del data by key
     *
     * @param {K} key
     * @returns {Promise<void>}
     * @example
     * await flashStore.delete(1)
     */
    delete(key) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('FlashStore', 'delete(%s)', key);
            yield this.levelDb.del(key);
        });
    }
    /**
     * @typedef IteratorOptions
     *
     * @property { any }      gt       - Matches values that are greater than a specified value
     * @property { any }      gte      - Matches values that are greater than or equal to a specified value.
     * @property { any }      lt       - Matches values that are less than a specified value.
     * @property { any }      lte      - Matches values that are less than or equal to a specified value.
     * @property { boolean }  reverse  - Reverse the result set
     * @property { number }   limit    - Limits the number in the result set.
     * @property { any }      prefix   - Make the same prefix key get together.
     */
    /**
     * Find keys by IteratorOptions
     *
     * @param {IteratorOptions} [options={}]
     * @returns {AsyncIterableIterator<K>}
     * @example
     * const flashStore = new FlashStore('flashstore.workdir')
     * for await(const key of flashStore.keys({gte: 1})) {
     *   console.log(key)
     * }
     */
    keys(options = {}) {
        return __asyncGenerator(this, arguments, function* keys_1() {
            var e_1, _a;
            config_1.log.verbose('FlashStore', 'keys()');
            // options = Object.assign(options, {
            //   keys   : true,
            //   values : false,
            // })
            if (options.prefix) {
                if (options.gte || options.lte) {
                    throw new Error('can not specify `prefix` with `gte`/`lte` together.');
                }
                options.gte = options.prefix;
                options.lte = options.prefix + '\xff';
            }
            try {
                for (var _b = __asyncValues(this.entries(options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const [key] = _c.value;
                    yield yield __await(key);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Find all values
     *
     * @returns {AsyncIterableIterator<V>}
     * @example
     * const flashStore = new FlashStore('flashstore.workdir')
     * for await(const value of flashStore.values()) {
     *   console.log(value)
     * }
     */
    values(options = {}) {
        return __asyncGenerator(this, arguments, function* values_1() {
            var e_2, _a;
            config_1.log.verbose('FlashStore', 'values()');
            try {
                // options = Object.assign(options, {
                //   keys   : false,
                //   values : true,
                // })
                for (var _b = __asyncValues(this.entries(options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const [, value] = _c.value;
                    yield yield __await(value);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get the size of the database
     * @returns {Promise<number>}
     * @example
     * const size = await flashStore.size
     * console.log(`database size: ${size}`)
     */
    get size() {
        config_1.log.verbose('FlashStore', 'size()');
        let future = Promise.resolve();
        /**
         * the size will be zero if there's never a put/get operation
         *  because I guess that it was lazy initialized.
         */
        if (this.medeaKeyDir.size === 0) {
            future = future.then(() => this.get('foobar'));
        }
        return future.then(() => this.medeaKeyDir.size);
        // // TODO: is there a better way to count all items from the db?
        // return new Promise<number>(async (resolve, reject) => {
        //   try {
        //     let count = 0
        //     for await (const _ of this) {
        //       count++
        //     }
        //     resolve(count)
        //   } catch (e) {
        //     reject(e)
        //   }
        // })
    }
    /**
     * FIXME: use better way to do this
     */
    has(key) {
        return __awaiter(this, void 0, void 0, function* () {
            const val = yield this.get(key);
            return !!val;
        });
    }
    /**
     * TODO: use better way to do this with leveldb
     */
    clear() {
        var e_3, _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                for (var _b = __asyncValues(this.keys()), _c; _c = yield _b.next(), !_c.done;) {
                    const key = _c.value;
                    yield this.delete(key);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * @private
     */
    entries(options) {
        return __asyncGenerator(this, arguments, function* entries_1() {
            config_1.log.verbose('FlashStore', '*entries(%s)', JSON.stringify(options));
            const iterator = this.levelDb.db.iterator(options);
            while (true) {
                const pair = yield __await(new Promise((resolve, reject) => {
                    iterator.next(function (err, key, val) {
                        if (err) {
                            reject(err);
                        }
                        if (!key && !val) {
                            return resolve(null);
                        }
                        if (val) {
                            // FIXME: issue #2
                            val = JSON.parse(val);
                        }
                        return resolve([key, val]);
                    });
                }));
                if (!pair) {
                    break;
                }
                yield yield __await(pair);
            }
        });
    }
    [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
            config_1.log.verbose('FlashStore', '*[Symbol.asyncIterator]()');
            yield __await(yield* __asyncDelegator(__asyncValues(this.entries())));
        });
    }
    // /**
    //  * @private
    //  * @deprecated
    //  */
    // public async * streamAsyncIterator (): AsyncIterator<[K, V]> {
    //   log.warn('FlashStore', 'DEPRECATED *[Symbol.asyncIterator]()')
    //   const readStream = this.levelDb.createReadStream()
    //   const endPromise = new Promise<false>((resolve, reject) => {
    //     readStream
    //       .once('end',  () => resolve(false))
    //       .once('error', reject)
    //   })
    //   let pair: [K, V] | false
    //   do {
    //     const dataPromise = new Promise<[K, V]>(resolve => {
    //       readStream.once('data', (data: any) => resolve([data.key, data.value]))
    //     })
    //     pair = await Promise.race([
    //       dataPromise,
    //       endPromise,
    //     ])
    //     if (pair) {
    //       yield pair
    //     }
    //   } while (pair)
    // }
    /**
     * FlashStore will not be able to be used anymore after it has been closed.
     */
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('FlashStore', 'close()');
            yield this.levelDb.close();
            if (this.lockFd !== 0) {
                fs_ext_1.flockSync(this.lockFd, 'un');
                fs_1.default.closeSync(this.lockFd);
                this.lockFd = 0;
            }
        });
    }
    /**
     * Destroy the database
     *
     * @returns {Promise<void>}
     */
    destroy() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('FlashStore', 'destroy()');
            yield this.levelDb.close();
            yield new Promise(resolve => rimraf_1.default(this.workdir, resolve));
        });
    }
}
exports.FlashStore = FlashStore;
exports.default = FlashStore;
//# sourceMappingURL=flash-store.js.map