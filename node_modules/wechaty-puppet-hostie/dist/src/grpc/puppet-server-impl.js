"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const grpc_1 = __importDefault(require("grpc"));
const file_box_1 = require("file-box");
const wrappers_pb_1 = require("google-protobuf/google/protobuf/wrappers_pb");
const grpc_2 = require("@chatie/grpc");
const wechaty_puppet_1 = require("wechaty-puppet");
const config_1 = require("../config");
const grpcError = (method, e, callback) => {
    config_1.log.error('GrpcServerImpl', `${method}() rejection: %s`, e && e.message);
    const error = Object.assign(Object.assign({}, e), { code: grpc_1.default.status.INTERNAL, details: e.message });
    return callback(error, null);
};
/**
 * Implements the SayHello RPC method.
 */
function getServerImpl(puppet) {
    let eventStream;
    const puppetServerImpl = {
        contactAlias: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'contactAlias()');
            const id = call.request.getId();
            /**
             * Set
             */
            {
                const aliasWrapper = call.request.getAlias();
                if (aliasWrapper) {
                    try {
                        yield puppet.contactAlias(id, aliasWrapper.getValue());
                        return callback(null, new grpc_2.ContactAliasResponse());
                    }
                    catch (e) {
                        return grpcError('contactAlias', e, callback);
                    }
                }
            }
            /**
             * Get
             */
            try {
                const alias = yield puppet.contactAlias(id);
                const aliasWrapper = new wrappers_pb_1.StringValue();
                aliasWrapper.setValue(alias);
                const response = new grpc_2.ContactAliasResponse();
                response.setAlias(aliasWrapper);
                return callback(null, response);
            }
            catch (e) {
                return grpcError('contactAlias', e, callback);
            }
        }),
        contactAvatar: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'contactAvatar()');
            const id = call.request.getId();
            /**
             * Set
             */
            try {
                const fileBoxWrapper = call.request.getFilebox();
                if (fileBoxWrapper) {
                    const fileBox = file_box_1.FileBox.fromJSON(fileBoxWrapper.getValue());
                    yield puppet.contactAvatar(id, fileBox);
                    return callback(null, new grpc_2.ContactAvatarResponse());
                }
            }
            catch (e) {
                return grpcError('contactAvatar', e, callback);
            }
            /**
             * Get
             */
            try {
                const fileBox = yield puppet.contactAvatar(id);
                const fileBoxWrapper = new wrappers_pb_1.StringValue();
                fileBoxWrapper.setValue(JSON.stringify(fileBox));
                const response = new grpc_2.ContactAvatarResponse();
                response.setFilebox(fileBoxWrapper);
                return callback(null, response);
            }
            catch (e) {
                return grpcError('contactAvatar', e, callback);
            }
        }),
        contactList: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'contactList()');
            void call; // empty request
            try {
                const idList = yield puppet.contactList();
                const response = new grpc_2.ContactListResponse();
                response.setIdsList(idList);
                return callback(null, response);
            }
            catch (e) {
                return grpcError('contactList', e, callback);
            }
        }),
        contactPayload: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'contactPayload()');
            const id = call.request.getId();
            try {
                const payload = yield puppet.contactPayload(id);
                const response = new grpc_2.ContactPayloadResponse();
                response.setAddress(payload.address || '');
                response.setAlias(payload.alias || '');
                response.setAvatar(payload.avatar);
                response.setCity(payload.city || '');
                response.setFriend(payload.friend || false);
                response.setGender(payload.gender);
                response.setId(payload.id);
                response.setName(payload.name);
                response.setProvince(payload.province || '');
                response.setSignature(payload.signature || '');
                response.setStar(payload.star || false);
                response.setType(payload.type);
                response.setWeixin(payload.weixin || '');
                return callback(null, response);
            }
            catch (e) {
                return grpcError('contactPayload', e, callback);
            }
        }),
        contactSelfName: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'contactSelfName()');
            try {
                const name = call.request.getName();
                yield puppet.contactSelfName(name);
                return callback(null, new grpc_2.ContactSelfNameResponse());
            }
            catch (e) {
                return grpcError('contactSelfName', e, callback);
            }
        }),
        contactSelfQRCode: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'contactSelfName()');
            void call;
            try {
                const qrcode = yield puppet.contactSelfQRCode();
                const response = new grpc_2.ContactSelfQRCodeResponse();
                response.setQrcode(qrcode);
                return callback(null, response);
            }
            catch (e) {
                return grpcError('contactSelfQRCode', e, callback);
            }
        }),
        contactSelfSignature: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'contactSelfSignature()');
            try {
                const signature = call.request.getSignature();
                yield puppet.contactSelfSignature(signature);
                return callback(null, new grpc_2.ContactSelfSignatureResponse());
            }
            catch (e) {
                return grpcError('contactSelfSignature', e, callback);
            }
        }),
        ding: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'ding()');
            try {
                const data = call.request.getData();
                yield puppet.ding(data);
                return callback(null, new grpc_2.DingResponse());
            }
            catch (e) {
                return grpcError('ding', e, callback);
            }
        }),
        /**
         *
         * Bridge Event Emitter Events
         *
         */
        event: (streamCall) => {
            config_1.log.verbose('GrpcServerImpl', 'event()');
            if (eventStream) {
                config_1.log.error('GrpcServerImpl', 'event() called twice, which should not: return with error');
                const error = Object.assign(Object.assign({}, new Error('GrpcServerImpl.event() can not call twice.')), { code: grpc_1.default.status.ALREADY_EXISTS, details: 'GrpcServerImpl.event() can not call twice.' });
                /**
                  * Send error from gRPC server stream:
                  *  https://github.com/grpc/grpc-node/issues/287#issuecomment-383218225
                  *
                  * Streaming RPCs
                  *  - https://grpc.io/docs/tutorials/basic/node/
                  *    Only one of 'error' or 'end' will be emitted. Finally, the 'status' event fires when the server sends the status.
                  */
                streamCall.emit('error', error);
                return;
            }
            eventStream = streamCall;
            /**
             * Detect if Inexor Core is gone (GRPC disconnects)
             *  https://github.com/grpc/grpc/issues/8117#issuecomment-362198092
             */
            eventStream.on('cancelled', function () {
                config_1.log.verbose('GrpcServerImpl', 'event() eventStream.on(cancelled) fired with arguments: %s', JSON.stringify(arguments));
                eventStream = undefined;
            });
            eventStream.on('error', err => {
                config_1.log.verbose('GrpcServerImpl', 'event() eventStream.on(error) fired: %s', err);
                eventStream = undefined;
            });
            eventStream.on('finish', () => {
                config_1.log.verbose('GrpcServerImpl', 'event() eventStream.on(finish) fired');
                eventStream = undefined;
            });
            eventStream.on('end', () => {
                config_1.log.verbose('GrpcServerImpl', 'event() eventStream.on(end) fired');
                eventStream = undefined;
            });
            eventStream.on('close', () => {
                config_1.log.verbose('GrpcServerImpl', 'event() eventStream.on(close) fired');
                eventStream = undefined;
            });
            const grpcEmit = (type, obj) => {
                const response = new grpc_2.EventResponse();
                response.setType(type);
                response.setPayload(JSON.stringify(obj));
                if (eventStream) {
                    eventStream.write(response);
                }
                else {
                    config_1.log.warn('GrpcServerImpl', 'event() grpcEmit() eventStream undefined');
                }
            };
            const eventNameList = Object.keys(wechaty_puppet_1.PUPPET_EVENT_DICT);
            for (const eventName of eventNameList) {
                config_1.log.verbose('GrpcServerImpl', 'event() puppet.on(%s) registering...', eventName);
                switch (eventName) {
                    case 'dong':
                        puppet.on('dong', data => grpcEmit(grpc_2.EventType.EVENT_TYPE_DONG, { data }));
                        break;
                    case 'error':
                        puppet.on('error', error => grpcEmit(grpc_2.EventType.EVENT_TYPE_ERROR, { error }));
                        break;
                    case 'watchdog':
                        puppet.on('watchdog', data => grpcEmit(grpc_2.EventType.EVENT_TYPE_WATCHDOG, { data }));
                        break;
                    case 'friendship':
                        puppet.on('friendship', (friendshipId) => __awaiter(this, void 0, void 0, function* () { return grpcEmit(grpc_2.EventType.EVENT_TYPE_FRIENDSHIP, { friendshipId }); }));
                        break;
                    case 'login':
                        puppet.on('login', (contactId) => __awaiter(this, void 0, void 0, function* () { return grpcEmit(grpc_2.EventType.EVENT_TYPE_LOGIN, { contactId }); }));
                        break;
                    case 'logout':
                        puppet.on('logout', (contactId, reason) => __awaiter(this, void 0, void 0, function* () { return grpcEmit(grpc_2.EventType.EVENT_TYPE_LOGOUT, { contactId, reason }); }));
                        break;
                    case 'message':
                        puppet.on('message', (messageId) => __awaiter(this, void 0, void 0, function* () { return grpcEmit(grpc_2.EventType.EVENT_TYPE_MESSAGE, { messageId }); }));
                        break;
                    case 'ready':
                        puppet.on('ready', () => grpcEmit(grpc_2.EventType.EVENT_TYPE_READY, {}));
                        break;
                    case 'room-invite':
                        puppet.on('room-invite', (roomInvitationId) => __awaiter(this, void 0, void 0, function* () { return grpcEmit(grpc_2.EventType.EVENT_TYPE_ROOM_INVITE, { roomInvitationId }); }));
                        break;
                    case 'room-join':
                        puppet.on('room-join', (roomId, inviteeIdList, inviterId, timestamp) => {
                            grpcEmit(grpc_2.EventType.EVENT_TYPE_ROOM_JOIN, {
                                inviteeIdList,
                                inviterId,
                                roomId,
                                timestamp,
                            });
                        });
                        break;
                    case 'room-leave':
                        puppet.on('room-leave', (roomId, leaverIdList, removerId, timestamp) => {
                            grpcEmit(grpc_2.EventType.EVENT_TYPE_ROOM_LEAVE, {
                                leaverIdList,
                                removerId,
                                roomId,
                                timestamp,
                            });
                        });
                        break;
                    case 'room-topic':
                        puppet.on('room-topic', (roomId, newTopic, oldTopic, changerId, timestamp) => {
                            grpcEmit(grpc_2.EventType.EVENT_TYPE_ROOM_TOPIC, {
                                changerId,
                                newTopic,
                                oldTopic,
                                roomId,
                                timestamp,
                            });
                        });
                        break;
                    case 'scan':
                        puppet.on('scan', (qrcode, status, data) => {
                            grpcEmit(grpc_2.EventType.EVENT_TYPE_SCAN, {
                                data,
                                qrcode,
                                status,
                            });
                        });
                        break;
                    case 'reset':
                        // the `reset` event should be dealed internally, should not send out
                        break;
                    default:
                        throw new Error('eventName ' + eventName + ' unsupported!');
                }
            }
        },
        frendshipAccept: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'friendshipAccept()');
            try {
                const id = call.request.getId();
                yield puppet.friendshipAccept(id);
                return callback(null, new grpc_2.FriendshipAcceptResponse());
            }
            catch (e) {
                return grpcError('friendshipAccept', e, callback);
            }
        }),
        friendshipAdd: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'friendshipAccept()');
            try {
                const contactId = call.request.getContactId();
                const hello = call.request.getHello();
                yield puppet.friendshipAdd(contactId, hello);
                return callback(null, new grpc_2.FriendshipAddResponse());
            }
            catch (e) {
                return grpcError('friendshipAdd', e, callback);
            }
        }),
        friendshipPayload: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'friendshipAccept()');
            try {
                const id = call.request.getId();
                const payload = yield puppet.friendshipPayload(id);
                const payloadReceive = payload;
                const response = new grpc_2.FriendshipPayloadResponse();
                response.setContactId(payload.id);
                response.setHello(payload.hello || '');
                response.setId(payload.id);
                response.setScene(payloadReceive.scene);
                response.setStranger(payloadReceive.stranger || '');
                response.setTicket(payloadReceive.ticket);
                response.setType(payload.type);
                return callback(null, response);
            }
            catch (e) {
                return grpcError('friendshipPayload', e, callback);
            }
        }),
        friendshipSearchPhone: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'friendshipSearchPhone()');
            try {
                const phone = call.request.getPhone();
                const contactId = yield puppet.friendshipSearchPhone(phone);
                const response = new grpc_2.FriendshipSearchPhoneResponse();
                if (contactId) {
                    const contactIdWrapper = new wrappers_pb_1.StringValue();
                    contactIdWrapper.setValue(contactId);
                    response.setContactId(contactIdWrapper);
                }
                return callback(null, response);
            }
            catch (e) {
                return grpcError('friendshipSearchPhone', e, callback);
            }
        }),
        friendshipSearchWeixin: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'friendshipSearchWeixin()');
            try {
                const weixin = call.request.getWeixin();
                const contactId = yield puppet.friendshipSearchWeixin(weixin);
                const response = new grpc_2.FriendshipSearchWeixinResponse();
                if (contactId) {
                    const contactIdWrapper = new wrappers_pb_1.StringValue();
                    contactIdWrapper.setValue(contactId);
                    response.setContactId(contactIdWrapper);
                }
                return callback(null, response);
            }
            catch (e) {
                return grpcError('friendshipSearchWeixin', e, callback);
            }
        }),
        logout: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'logout()');
            void call; // empty arguments
            try {
                yield puppet.logout();
                return callback(null, new grpc_2.LogoutResponse());
            }
            catch (e) {
                return grpcError('logout', e, callback);
            }
        }),
        messageContact: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'messageContact()');
            try {
                const id = call.request.getId();
                const contactId = yield puppet.messageContact(id);
                const response = new grpc_2.MessageContactResponse();
                response.setId(contactId);
                return callback(null, response);
            }
            catch (e) {
                return grpcError('messageContact', e, callback);
            }
        }),
        messageFile: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'messageFile()');
            try {
                const id = call.request.getId();
                const fileBox = yield puppet.messageFile(id);
                const response = new grpc_2.MessageFileResponse();
                response.setFilebox(JSON.stringify(fileBox));
                return callback(null, response);
            }
            catch (e) {
                return grpcError('messageFile', e, callback);
            }
        }),
        messageMiniProgram: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'messageMiniProgram()');
            try {
                const id = call.request.getId();
                const payload = yield puppet.messageMiniProgram(id);
                const response = new grpc_2.MessageMiniProgramResponse();
                response.setMiniProgram(JSON.stringify(payload));
                return callback(null, response);
            }
            catch (e) {
                return grpcError('messageMiniProgram', e, callback);
            }
        }),
        messagePayload: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'messagePayload()');
            try {
                const id = call.request.getId();
                const payload = yield puppet.messagePayload(id);
                const response = new grpc_2.MessagePayloadResponse();
                response.setFilename(payload.filename || '');
                response.setFromId(payload.fromId || '');
                response.setId(payload.id);
                response.setMentionIdsList(payload.mentionIdList);
                response.setRoomId(payload.roomId || '');
                response.setText(payload.text || '');
                response.setTimestamp(payload.timestamp);
                response.setToId(payload.toId || '');
                response.setType(payload.type);
                return callback(null, response);
            }
            catch (e) {
                return grpcError('messagePayload', e, callback);
            }
        }),
        messageRecall: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'messageRecall()');
            try {
                const id = call.request.getId();
                const success = yield puppet.messageRecall(id);
                const response = new grpc_2.MessageRecallResponse();
                response.setSuccess(success);
                return callback(null, response);
            }
            catch (e) {
                grpcError('messageRecall', e, callback);
            }
        }),
        messageSendContact: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'messageSendContact()');
            try {
                const conversationId = call.request.getConversationId();
                const contactId = call.request.getContactId();
                const messageId = yield puppet.messageSendContact(conversationId, contactId);
                const response = new grpc_2.MessageSendContactResponse();
                if (messageId) {
                    const idWrapper = new wrappers_pb_1.StringValue();
                    idWrapper.setValue(messageId);
                    response.setId(idWrapper);
                }
                return callback(null, response);
            }
            catch (e) {
                return grpcError('messageSendContact', e, callback);
            }
        }),
        messageSendFile: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'messageSendFile()');
            try {
                const conversationId = call.request.getConversationId();
                const jsonText = call.request.getFilebox();
                const fileBox = file_box_1.FileBox.fromJSON(jsonText);
                const messageId = yield puppet.messageSendFile(conversationId, fileBox);
                const response = new grpc_2.MessageSendFileResponse();
                if (messageId) {
                    const idWrapper = new wrappers_pb_1.StringValue();
                    idWrapper.setValue(messageId);
                    response.setId(idWrapper);
                }
                return callback(null, response);
            }
            catch (e) {
                return grpcError('messageSendFile', e, callback);
            }
        }),
        messageSendMiniProgram: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'messageSendMiniProgram()');
            try {
                const conversationId = call.request.getConversationId();
                const jsonText = call.request.getMiniProgram();
                const payload = JSON.parse(jsonText);
                const messageId = yield puppet.messageSendMiniProgram(conversationId, payload);
                const response = new grpc_2.MessageSendMiniProgramResponse();
                if (messageId) {
                    const idWrapper = new wrappers_pb_1.StringValue();
                    idWrapper.setValue(messageId);
                    response.setId(idWrapper);
                }
                return callback(null, response);
            }
            catch (e) {
                return grpcError('messageSendMiniProgram', e, callback);
            }
        }),
        messageSendText: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'messageSendText()');
            try {
                const conversationId = call.request.getConversationId();
                const text = call.request.getText();
                const mentionIdList = call.request.getMentonalIdsList();
                const messageId = yield puppet.messageSendText(conversationId, text, mentionIdList);
                const response = new grpc_2.MessageSendTextResponse();
                if (messageId) {
                    const idWrapper = new wrappers_pb_1.StringValue();
                    idWrapper.setValue(messageId);
                    response.setId(idWrapper);
                }
                return callback(null, response);
            }
            catch (e) {
                return grpcError('messageSendText', e, callback);
            }
        }),
        messageSendUrl: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'messageSendUrl()');
            try {
                const conversationId = call.request.getConversationId();
                const jsonText = call.request.getUrlLink();
                const payload = JSON.parse(jsonText);
                const messageId = yield puppet.messageSendUrl(conversationId, payload);
                const response = new grpc_2.MessageSendTextResponse();
                if (messageId) {
                    const idWrapper = new wrappers_pb_1.StringValue();
                    idWrapper.setValue(messageId);
                    response.setId(idWrapper);
                }
                return callback(null, response);
            }
            catch (e) {
                return grpcError('messageSendUrl', e, callback);
            }
        }),
        messageUrl: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'messageUrl()');
            try {
                const id = call.request.getId();
                const payload = yield puppet.messageUrl(id);
                const response = new grpc_2.MessageUrlResponse();
                response.setUrlLink(JSON.stringify(payload));
                return callback(null, response);
            }
            catch (e) {
                return grpcError('messageUrl', e, callback);
            }
        }),
        roomAdd: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'roomAdd()');
            try {
                const roomId = call.request.getId();
                const contactId = call.request.getContactId();
                yield puppet.roomAdd(roomId, contactId);
                return callback(null, new grpc_2.RoomAddResponse());
            }
            catch (e) {
                return grpcError('roomAdd', e, callback);
            }
        }),
        roomAnnounce: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'roomAnnounce()');
            try {
                const roomId = call.request.getId();
                /**
                 * Set
                 */
                {
                    const textWrapper = call.request.getText();
                    if (textWrapper) {
                        const text = textWrapper.getValue();
                        yield puppet.roomAnnounce(roomId, text);
                        return callback(null, new grpc_2.RoomAnnounceResponse());
                    }
                }
                /**
                 * Get
                 */
                const text = yield puppet.roomAnnounce(roomId);
                const textWrapper = new wrappers_pb_1.StringValue();
                textWrapper.setValue(text);
                const response = new grpc_2.RoomAnnounceResponse();
                response.setText(textWrapper);
                return callback(null, response);
            }
            catch (e) {
                return grpcError('roomAnnounce', e, callback);
            }
        }),
        roomAvatar: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'roomAvatar()');
            try {
                const roomId = call.request.getId();
                const fileBox = yield puppet.roomAvatar(roomId);
                const response = new grpc_2.RoomAvatarResponse();
                response.setFilebox(JSON.stringify(fileBox));
                return callback(null, response);
            }
            catch (e) {
                return grpcError('roomAvatar', e, callback);
            }
        }),
        roomCreate: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'roomCreate()');
            try {
                const contactIdList = call.request.getContactIdsList();
                const topic = call.request.getTopic();
                const roomId = yield puppet.roomCreate(contactIdList, topic);
                const response = new grpc_2.RoomCreateResponse();
                response.setId(roomId);
                return callback(null, response);
            }
            catch (e) {
                return grpcError('roomCreate', e, callback);
            }
        }),
        roomDel: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'roomDel()');
            try {
                const roomId = call.request.getId();
                const contactId = call.request.getContactId();
                yield puppet.roomDel(roomId, contactId);
                return callback(null, new grpc_2.RoomDelResponse());
            }
            catch (e) {
                return grpcError('roomDel', e, callback);
            }
        }),
        roomInvitationAccept: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'roomInvitationAccept()');
            try {
                const id = call.request.getId();
                yield puppet.roomInvitationAccept(id);
                return callback(null, new grpc_2.RoomInvitationAcceptResponse());
            }
            catch (e) {
                return grpcError('roomInvitationAccept', e, callback);
            }
        }),
        roomInvitationPayload: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'roomInvitationPayload()');
            try {
                const roomInvitationId = call.request.getId();
                /**
                  * Set
                  */
                {
                    const payloadWrapper = call.request.getPayload();
                    if (payloadWrapper) {
                        const jsonText = payloadWrapper.getValue();
                        const payload = JSON.parse(jsonText);
                        yield puppet.roomInvitationPayload(roomInvitationId, payload);
                        return callback(null, new grpc_2.RoomInvitationPayloadResponse());
                    }
                }
                /**
                 * Get
                 */
                const payload = yield puppet.roomInvitationPayload(roomInvitationId);
                const response = new grpc_2.RoomInvitationPayloadResponse();
                response.setAvatar(payload.avatar);
                response.setId(payload.id);
                response.setInvitation(payload.invitation);
                response.setInviterId(payload.inviterId);
                response.setMemberCount(payload.memberCount);
                response.setMemberIdsList(payload.memberIdList);
                response.setTimestamp(payload.timestamp);
                response.setTopic(payload.topic);
                return callback(null, response);
            }
            catch (e) {
                return grpcError('roomInvitationPayload', e, callback);
            }
        }),
        roomList: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'roomList()');
            void call;
            try {
                const roomIdList = yield puppet.roomList();
                const response = new grpc_2.RoomListResponse();
                response.setIdsList(roomIdList);
                return callback(null, response);
            }
            catch (e) {
                return grpcError('roomList', e, callback);
            }
        }),
        roomMemberList: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'roomMemberList()');
            try {
                const roomId = call.request.getId();
                const roomMemberIdList = yield puppet.roomMemberList(roomId);
                const response = new grpc_2.RoomMemberListResponse();
                response.setMemberIdsList(roomMemberIdList);
                return callback(null, response);
            }
            catch (e) {
                return grpcError('roomMemberList', e, callback);
            }
        }),
        roomMemberPayload: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'roomMemberPayload()');
            try {
                const roomId = call.request.getId();
                const memberId = call.request.getMemberId();
                const payload = yield puppet.roomMemberPayload(roomId, memberId);
                const response = new grpc_2.RoomMemberPayloadResponse();
                response.setAvatar(payload.avatar);
                response.setId(payload.id);
                response.setInviterId(payload.inviterId || '');
                response.setName(payload.name);
                response.setRoomAlias(payload.roomAlias || '');
                return callback(null, response);
            }
            catch (e) {
                return grpcError('roomMemberPayload', e, callback);
            }
        }),
        roomPayload: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'roomPayload()');
            try {
                const roomId = call.request.getId();
                const payload = yield puppet.roomPayload(roomId);
                const response = new grpc_2.RoomPayloadResponse();
                response.setAdminIdsList(payload.adminIdList);
                response.setAvatar(payload.avatar || '');
                response.setId(payload.id);
                response.setMemberIdsList(payload.memberIdList);
                response.setOwnerId(payload.ownerId || '');
                response.setTopic(payload.topic);
                return callback(null, response);
            }
            catch (e) {
                return grpcError('roomPayload', e, callback);
            }
        }),
        roomQRCode: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'roomQRCode()');
            try {
                const roomId = call.request.getId();
                const qrcode = yield puppet.roomQRCode(roomId);
                const response = new grpc_2.RoomQRCodeResponse();
                response.setQrcode(qrcode);
                return callback(null, response);
            }
            catch (e) {
                return grpcError('roomQRCode', e, callback);
            }
        }),
        roomQuit: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'roomQuit()');
            try {
                const roomId = call.request.getId();
                yield puppet.roomQuit(roomId);
                return callback(null, new grpc_2.RoomQuitResponse());
            }
            catch (e) {
                return grpcError('roomQuit', e, callback);
            }
        }),
        roomTopic: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'roomTopic()');
            try {
                const roomId = call.request.getId();
                /**
                 * Set
                 */
                {
                    const topicWrapper = call.request.getTopic();
                    if (topicWrapper) {
                        const topic = topicWrapper.getValue();
                        yield puppet.roomTopic(roomId, topic);
                        return callback(null, new grpc_2.RoomTopicResponse());
                    }
                }
                /**
                 * Get
                 */
                const topic = yield puppet.roomTopic(roomId);
                const topicWrapper = new wrappers_pb_1.StringValue();
                topicWrapper.setValue(topic);
                const response = new grpc_2.RoomTopicResponse();
                response.setTopic(topicWrapper);
                return callback(null, response);
            }
            catch (e) {
                return grpcError('roomTopic', e, callback);
            }
        }),
        start: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'start()');
            void call;
            try {
                yield puppet.start();
                return callback(null, new grpc_2.StartResponse());
            }
            catch (e) {
                return grpcError('start', e, callback);
            }
        }),
        stop: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'stop()');
            void call;
            try {
                if (eventStream) {
                    eventStream.end();
                    eventStream = undefined;
                }
                else {
                    config_1.log.error('GrpcServerImpl', 'stop() eventStream is undefined?');
                }
                yield puppet.stop();
                return callback(null, new grpc_2.StopResponse());
            }
            catch (e) {
                return grpcError('stop', e, callback);
            }
        }),
        tagContactAdd: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'tagContactAdd()');
            try {
                const tagId = call.request.getId();
                const contactId = call.request.getContactId();
                yield puppet.tagContactAdd(tagId, contactId);
                return callback(null, new grpc_2.TagContactAddResponse());
            }
            catch (e) {
                return grpcError('tagContactAdd', e, callback);
            }
        }),
        tagContactDelete: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'tagContactDelete()');
            try {
                const tagId = call.request.getId();
                yield puppet.tagContactDelete(tagId);
                return callback(null, new grpc_2.TagContactDeleteResponse());
            }
            catch (e) {
                return grpcError('tagContactDelete', e, callback);
            }
        }),
        tagContactList: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'tagContactList()');
            try {
                const contactIdWrapper = call.request.getContactId();
                /**
                 * for a specific contact
                 */
                if (contactIdWrapper) {
                    const contactId = contactIdWrapper.getValue();
                    const tagIdList = yield puppet.tagContactList(contactId);
                    const response = new grpc_2.TagContactListResponse();
                    response.setIdsList(tagIdList);
                    return callback(null, new grpc_2.TagContactListResponse());
                }
                /**
                 * get all tags for all contact
                 */
                const tagIdList = yield puppet.tagContactList();
                const response = new grpc_2.TagContactListResponse();
                response.setIdsList(tagIdList);
                return callback(null, response);
            }
            catch (e) {
                return grpcError('tagContactList', e, callback);
            }
        }),
        tagContactRemove: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'tagContactRemove()');
            try {
                const tagId = call.request.getId();
                const contactId = call.request.getContactId();
                yield puppet.tagContactRemove(tagId, contactId);
                return callback(null, new grpc_2.TagContactRemoveResponse());
            }
            catch (e) {
                return grpcError('tagContactRemove', e, callback);
            }
        }),
        version: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('GrpcServerImpl', 'version() v%s', puppet.version());
            void call;
            try {
                const version = puppet.version();
                const response = new grpc_2.VersionResponse();
                response.setVersion(version);
                return callback(null, response);
            }
            catch (e) {
                return grpcError('version', e, callback);
            }
        }),
    };
    return puppetServerImpl;
}
exports.getServerImpl = getServerImpl;
//# sourceMappingURL=puppet-server-impl.js.map